/* MIT License

Copyright (c) 2021 Ryan Boggs

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

using Serialize.OpenXml.CodeGen.Extentions;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Serialize.OpenXml.CodeGen
{
    /// <summary>
    /// Class designed to monitor the variable names generated by a single type.
    /// </summary>
    /// <remarks>
    /// This will be used only for code generation of
    /// <see cref="DocumentFormat.OpenXml.OpenXmlElement"/> objects.
    /// </remarks>
    public class TypeMonitor : IDictionary<string, bool>
    {
        #region Private Instance Fields

        /// <summary>
        /// Holds the <see cref="Type"/> that the current instance will
        /// represent for its lifetime.
        /// </summary>
        private readonly Type _type;

        /// <summary>
        /// The object <see cref="Dictionary{TKey, TValue}"/> containing all of the
        /// variable names that have already been generated and their 'consumed'
        /// indicators.
        /// </summary>
#pragma warning disable IDE0044 // Add readonly modifier
        private Dictionary<string, bool> _values = new Dictionary<string, bool>();
#pragma warning restore IDE0044 // Add readonly modifier

        #endregion

        #region Public Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="TypeMonitor"/> class with
        /// the type that it will represent.
        /// </summary>
        /// <param name="t">
        /// The <see cref="Type"/> that this new object will represent.
        /// </param>
        public TypeMonitor(Type t)
        {
            _type = t ?? throw new ArgumentNullException(nameof(t));
        }

        #endregion

        #region Public Instance Properties

        /// <inheritdoc/>
        public bool this[string key]
        {
            get => _values[key];
            set => _values[key] = value;
        }

        /// <inheritdoc/>
        public ICollection<string> Keys => _values.Keys;

        /// <inheritdoc/>
        public ICollection<bool> Values => _values.Values;

        /// <inheritdoc/>
        public int Count => _values.Count;

        /// <inheritdoc/>
        public bool IsReadOnly => false;

        /// <summary>
        /// Gets the <see cref="Type"/> that the current object represents.
        /// </summary>
        public Type Type { get => _type; }

        #endregion

        #region Public Instance Methods

        /// <inheritdoc/>
        public void Add(string key, bool value) => _values.Add(key, value);

        /// <inheritdoc/>
        public bool ContainsKey(string key) => _values.ContainsKey(key);

        /// <summary>
        /// Retrieves an existing or new variable name, depending on what is
        /// available at the time, to generate new code statements with.
        /// </summary>
        /// <param name="namespaces">
        /// Collection <see cref="IDictionary{TKey, TValue}"/> used to keep
        /// track of all openxml namespaces used during the process.
        /// </param>
        /// <param name="varName">
        /// The variable name to use.
        /// </param>
        /// <returns>
        /// <see langword="true"/> if <paramref name="varName"/> already exists
        /// in existing generated code with constructor statements; otherwise
        /// <see langword="false"/> is returned, indicating that no existing
        /// generated code yet exists for <paramref name="varName"/>.
        /// </returns>
        public bool GetVariableName(IDictionary<string, string> namespaces, out string varName)
        {
            if (_values.Count > 0 && _values.Values.Count(v => v) > 0)
            {
                varName = _values.LastOrDefault(v => v.Value).Key;
                _values[varName] = false;
                return true;
            }

            int tries = _values.Count;
            varName = Type.GenerateVariableName(tries, namespaces);
            _values.Add(varName, false);
            return false;
        }

        /// <inheritdoc/>
        public bool TryGetValue(string key, out bool value)
        {
            return _values.TryGetValue(key, out value);
        }

        #endregion

        #region Private Instance Methods;

        /// <inheritdoc/>
        void ICollection<KeyValuePair<string, bool>>.Add(KeyValuePair<string, bool> item)
        {
            Add(item.Key, item.Value);
        }

        /// <inheritdoc/>
        void ICollection<KeyValuePair<string, bool>>.Clear() => _values.Clear();

        /// <inheritdoc/>
        bool ICollection<KeyValuePair<string, bool>>.Contains(KeyValuePair<string, bool> item)
        {
            return ((IDictionary<string, bool>)_values).Contains(item);
        }

        /// <inheritdoc/>
        void ICollection<KeyValuePair<string, bool>>.CopyTo(KeyValuePair<string, bool>[] array, int arrayIndex)
        {
            ((ICollection<KeyValuePair<string, bool>>)_values).CopyTo(array, arrayIndex);
        }

        /// <inheritdoc/>
        IEnumerator<KeyValuePair<string, bool>> IEnumerable<KeyValuePair<string, bool>>.GetEnumerator()
        {
            return ((IEnumerable<KeyValuePair<string, bool>>)_values).GetEnumerator();
        }

        /// <inheritdoc/>
        bool IDictionary<string, bool>.Remove(string key)
        {
            return _values.Remove(key);
        }

        /// <inheritdoc/>
        public bool Remove(KeyValuePair<string, bool> item)
        {
            return ((ICollection<KeyValuePair<string, bool>>)_values).Remove(item);
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return _values.GetEnumerator();
        }

        #endregion
    }
}
